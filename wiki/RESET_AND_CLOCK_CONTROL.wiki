= Reset And Clock Control (RCC) =

== Reset circuit ==

[https://armtutorial.googlecode.com/svn/trunk/image/Reset_Circuit.png]

== Clock tree ==

[https://armtutorial.googlecode.com/svn/trunk/image/Clock_Tree.png]

Three different clock sources can be used to drive the system clock (SYSCLK):

  ● HSI oscillator clock

  ● HSE oscillator clock

  ● PLL clock

The devices have the following two secondary clock sources:

  ● 40 kHz low speed internal RC (LSI RC) which drives the independent watchdog and optionally the RTC used for Auto-wakeup from Stop/Standby mode.

  ● 32.768 kHz low speed external crystal (LSE crystal) which optionally drives the realtime clock (RTCCLK)

Each clock source can be switched on or off independently when it is not used, to optimize power consumption.

= RCC Register Map =

[https://armtutorial.googlecode.com/svn/trunk/image/RCC_MAP.png]

= Example =

{{{

#define __RCC_CR_VAL               0x01010082
#define __RCC_CFGR_VAL             0x001D8402
#define __HSE                      8000000

/*----------------------------------------------------------------------------
 STM32 clock setup.
 initializes the RCC register
 *----------------------------------------------------------------------------*/
__inline static void stm32_ClockSetup (void) {
  /* Clock Configuration*/

  RCC->CFGR = __RCC_CFGR_VAL;                        // set clock configuration register
  RCC->CR   = __RCC_CR_VAL;                          // set clock control register

  if (__RCC_CR_VAL & RCC_CR_HSION) {                 // if HSI enabled
    while ((RCC->CR & RCC_CR_HSIRDY) == 0);          // Wait for HSIRDY = 1 (HSI is ready)
  }

  if (__RCC_CR_VAL & RCC_CR_HSEON) {                 // if HSE enabled
    while ((RCC->CR & RCC_CR_HSERDY) == 0);          // Wait for HSERDY = 1 (HSE is ready)
  }

  if (__RCC_CR_VAL & RCC_CR_PLLON) {                 // if PLL enabled
    while ((RCC->CR & RCC_CR_PLLRDY) == 0);          // Wait for PLLRDY = 1 (PLL is ready)
  }

  /* Wait till SYSCLK is stabilized (depending on selected clock) */
  while ((RCC->CFGR & RCC_CFGR_SWS) != ((__RCC_CFGR_VAL<<2) & RCC_CFGR_SWS));
} // end of stm32_ClockSetup
}}}





 