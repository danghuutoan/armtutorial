= Bare Metal Programming =
  Việc tạo project từ zero người ta gọi là bare-metal programming, một chương trình standalone cho ARM tối thiểu phải có 2 thành phần:

{{{ 
   1> Source code.
   2> Linker script.
}}}

 Nếu chỉ có source code, trình biên dịch chỉ có thể tạo ra được các file đối tượng (object), thông thường có đuôi .o , để tạo thành file chạy (elf), trình biên dịch sẽ link các file đối tượng này và map chúng vào vùng nhớ vật lý để ARM có thể chạy được. Thông tin phân bố vùng nhớ của ARM được mô tả bởi linker script.

 Ví dụ ta có chương trình cộng 2 số (add.S) :

  {{{
        .text                     @ Code section
     start:                       @ Label, not really required
        mov   r0, #5              @ Load register r0 with the value 5
        mov   r1, #4              @ Load register r1 with the value 4
        add   r2, r1, r0          @ Add r0 and r1 and store in r2

     stop:   b stop               @ Infinite loop to stop execution
  }}}    

 Build source :

  {{{
  $ arm-none-eabi-as -o add.o add.S
  $ arm-none-eabi-nm add.o
    00000000 t start
    0000000c t stop
  }}}

 Ở file object, trình biên dịch sẽ gán tạm thời địa chỉ offset cho các symbol (bắc đầu từ 0x0), để tạo ra file chạy (elf) trình biên dịch cần phải link và map vị trí các symbol này vào bố cục bộ nhớ của ARM (memory layout).

 Ví dụ: Bộ nhớ của ARM được bắt đầu ở địa chỉ 0x08000000, ta dùng lệnh sau để sinh ra file chạy:

 {{{
  $ arm-none-eabi-ld -Ttext=0x08000000 -o add.elf add.o
  $ arm-none-eabi-nm add.elf 
    08000000 t start
    0800000c t stop
 }}}

 Option -Ttext=0x08000000 biểu thị section .text được bắt đầu ở địa chỉ 0x08000000, tương tự, có thể khai báo thông qua file linker script (script.ld) như sau:

  {{{
    SECTIONS {
         . = 0x08000000;
         .text : { * (.text); }
    }
  }}} 
 
 Ký hiệu . được gọi là location pointer, với khai báo như trên, section .text được bắt đầu ở vị trí 0x08000000,  wildcard { * (.text); } biểu thị tập hợp tất cả section .text của các file đối tượng cần link đến.

 {{{
  $ arm-none-eabi-ld -T script.ld -o add.elf add.o
  $ arm-none-eabi-nm add.elf 
    08000000 t start
    0800000c t stop
 }}} 
  
= STM32 GNU Project =
 
  Một chương trình đơn giản cho STM32 bao gồm các thành phần sau:

  {{{  
    - startup_stm32f4xx.S : Startup code.
    - gcc_arm.ld          : STM32 Linker script.
    - system_stm32f4xx.c  : STM32 system init.
    - main.c              : Chương trình ứng dụng.   
  }}}

  A> Startup code:

  Khi có sự kiện reset, trình phục vụ ngắt Reset_Handler sẽ được thực thi, Reset_Handler thực hiện các tác vụ sau:

  - Copy .data section từ FLASH sang RAM, .data section là phân đoạn chứa các biến được khởi động trị lúc khai báo (ví dụ: char c = 'a';), do RAM là bộ nhớ mất dữ liệu khi tắt nguồn điện vì vậy các trị khởi động trước này được lưu trữ vào bộ nhớ FLASH, ROM... Reset_Handler copy phân vùng này sang RAM trước khi thực thi các chương trình. Địa chỉ bắt đầu chứa phân vùng data trong FLASH được gọi là LMA (Load Memory Address), địa chỉ đầu tiên cần copy đến RAM được gọi là run-time address hoặc là VMA (Virtual Memory Address).
  
  - Khởi động các biến trên vùng .bss , vùng này nằm trên RAM đây là vùng chứa các biến không khởi động trị trong lúc khai báo (ví dụ : int d;), Reset_Handler thực thi việc xóa các biến này về zero. Đây là thao tác option, Reset_Handler có thể thự hiện hoặc không. Vì thế, chúng ta cần lưu ý không được hiểu nhầm khi một biến mới cấp phát có giá trị = zero là do trình biên dịch thực hiện. Một số trình biên dịch thông minh sẽ cho ra cảnh báo nếu ta vô tình lấy giá trị của một biến không được khởi động trước.

  - Khởi tạo con trỏ stack (SP).

  - Khởi tạp vùng heap (nếu chương trình có sử dụng thư viện cấp phát bộ nhớ động dynamic memory allocation)
  
  - Thực hiện khởi động hardware (low level init), bao gồm enable cache, CPU clock, peripheral... hoặc gọi đến 1 chương trình con khác để khởi động ngoại vi, ở ví dụ cho STM32, Reset_Handler gọi đến các hàm trong file system_stm32f4xx.c.

  - Sau khi thực hiện xong các bước trên Reset_Handler nhảy đến hàm main.

  Phân đoạn stack được khai báo như sau:  

   {{{
       .section .stack
       .align 3
       #ifdef __STACK_SIZE
         .equ    Stack_Size, __STACK_SIZE
       #else
         .equ    Stack_Size, 0x400
       #endif
       .globl    __StackTop
       .globl    __StackLimit
       __StackLimit:
       .space    Stack_Size
       .size __StackLimit, . - __StackLimit
       __StackTop:
       .size __StackTop, . - __StackTop
   }}}

   Vị trí bắt đầu của stack được biểu thị bởi symbol __StackTop, thông thường vùng stack được bố trí ở địa chỉ cao nhất của RAM. Khi gọi chương trình con, CPU thực hiện đưa dữ liệu tạm thời, con trỏ hiện tại của PC của chương trình, con trỏ stack SP sẽ giảm dần (POP) và tiến đến __StackLimit, khi thoát khỏi chương trình, các thông tin lưu trữ được lấy ra khỏi stack, con trỏ SP sẽ tăng dần và tiến về __StackTop. Hiện tượng tràn stack xảy ra khi con trỏ SP <= __StackLimit và chồng lấn lên các section khác trong RAM.

   __StackTop cũng là giá trị khởi động của SP khi reset hệ thống, cấu trúc ARM cho phép khởi động giá trị ban đầu SP bằng cách gán __StackTop vào giá trị của vector ngắt đầu tiên (ở địa chỉ 0x08000000 đối với STM32).

   ASM derective .space Stack_Size thực hiện cấp phát 1 vùng có kích thước Stack_Size cho phân đoạn stack.   

  Khai báo trương ứng trong linker script : gcc_arm.ld

  {{{
     MEMORY
     {
       FLASH (rx) : ORIGIN = 0x08000000, LENGTH = 2M
       RAM (rwx)  : ORIGIN = 0x20000000, LENGTH = 16K
     }

     ...

      .heap :
      {
	__end__ = .;
	end = __end__;
	*(.heap*)
	__HeapLimit = .;
      } > RAM

     /* .stack_dummy section doesn't contains any symbols. It is only
      * used for linker to calculate size of stack sections, and assign
      * values to stack symbols later */
      .stack_dummy :
      {
	 *(.stack)
      } > RAM

     /* Set stack top to end of RAM, and stack limit move down by
      * size of stack_dummy section */
      __StackTop = ORIGIN(RAM) + LENGTH(RAM);
      __StackLimit = __StackTop - SIZEOF(.stack_dummy);
      PROVIDE(__stack = __StackTop);    
       
  }}}   

   __StackTop nằm ở vị trí cuối cùng của RAM, được gán vào địa chỉ 0x20004000        

  Việc cấp phát vùng heap cũng tương tự

  {{{
       .section .heap
       .align 3
       #ifdef __HEAP_SIZE
         .equ    Heap_Size, __HEAP_SIZE
       #else
         .equ    Heap_Size, 0xC00
       #endif
       .globl    __HeapBase
       .globl    __HeapLimit
       __HeapBase:
       .if    Heap_Size
       .space    Heap_Size
       .endif
       .size __HeapBase, . - __HeapBase
       __HeapLimit:
       .size __HeapLimit, . - __HeapLimit
  }}}