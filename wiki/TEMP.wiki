= Bare Metal Programming =
  Việc tạo project từ zero người ta gọi là bare-metal programming, một chương trình standalone cho ARM tối thiểu phải có 2 thành phần:

{{{ 
   1> Source code.
   2> Linker script.
}}}

 Nếu chỉ có source code, trình biên dịch chỉ có thể tạo ra được các file đối tượng (object), thông thường có đuôi .o , để tạo thành file chạy (elf), trình biên dịch sẽ link các file đối tượng này và map chúng vào vùng nhớ vật lý để ARM có thể chạy được. Thông tin phân bố vùng nhớ của ARM được mô tả bởi linker script.

 Ví dụ ta có chương trình cộng 2 số (add.S) :

  {{{
        .text                     @ Code section
     start:                       @ Label, not really required
        mov   r0, #5              @ Load register r0 with the value 5
        mov   r1, #4              @ Load register r1 with the value 4
        add   r2, r1, r0          @ Add r0 and r1 and store in r2

     stop:   b stop               @ Infinite loop to stop execution
  }}}    

 Build source :

  {{{
  $ arm-none-eabi-as -o add.o add.S
  $ arm-none-eabi-nm add.o
    00000000 t start
    0000000c t stop
  }}}

 Ở file object, trình biên dịch sẽ gán tạm thời địa chỉ offset cho các symbol (bắc đầu từ 0x0), để tạo ra file chạy (elf) trình biên dịch cần phải link và map vị trí các symbol này vào bố cục bộ nhớ của ARM (memory layout).

 Ví dụ: Bộ nhớ của ARM được bắt đầu ở địa chỉ 0x08000000, ta dùng lệnh sau để sinh ra file chạy:

 {{{
  $ arm-none-eabi-ld -Ttext=0x08000000 -o add.elf add.o
  $ arm-none-eabi-nm add.elf 
    08000000 t start
    0800000c t stop
 }}}

 Option -Ttext=0x08000000 biểu thị section .text được bắt đầu ở địa chỉ 0x08000000, tương tự, có thể khai báo thông qua file linker script (script.ld) như sau:

  {{{
    SECTIONS {
         . = 0x08000000;
         .text : { * (.text); }
    }
  }}} 
 
 Ký hiệu . được gọi là location pointer, với khai báo như trên, section .text được bắt đầu ở vị trí 0x08000000,  wildcard { * (.text); } biểu thị tập hợp tất cả section .text của các file đối tượng cần link đến.

 {{{
  $ arm-none-eabi-ld -T script.ld -o add.elf add.o
  $ arm-none-eabi-nm add.elf 
    08000000 t start
    0800000c t stop
 }}} 
  
= STM32 GNU Project =
 
  Một chương trình đơn giản cho STM32 bao gồm các thành phần sau:

  {{{  
    - startup_stm32f4xx.S : Startup code.
    - gcc_arm.ld          : STM32 Linker script.
    - system_stm32f4xx.c  : STM32 system init.
    - main.c              : Chương trình ứng dụng.   
  }}}

  A> Startup code:

  Khi có sự kiện reset, trình phục vụ ngắt Reset_Handler sẽ được thực thi, Reset_Handler thực hiện các tác vụ sau:

  - Copy .data section từ FLASH sang RAM, .data section là phân đoạn chứa các biến được khởi động trị lúc khai báo (ví dụ: char c = 'a';), do RAM là bộ nhớ mất dữ liệu khi tắt nguồn điện vì vậy các trị khởi động trước này được lưu trữ vào bộ nhớ FLASH, ROM... Reset_Handler copy phân vùng này sang RAM trước khi thực thi các chương trình. Địa chỉ bắt đầu chứa phân vùng data trong FLASH được gọi là LMA (Load Memory Address), địa chỉ đầu tiên cần copy đến RAM được gọi là run-time address hoặc là VMA (Virtual Memory Address).
  
  - Khởi động các biến trên vùng .bss , vùng này nằm trên RAM đây là vùng chứa các biến không khởi động trị trong lúc khai báo (ví dụ : int d;), Reset_Handler thực thi việc xóa các biến này về zero. Đây là thao tác option, Reset_Handler có thể thự hiện hoặc không. Vì thế, chúng ta cần lưu ý không được hiểu nhầm khi một biến mới cấp phát có giá trị = zero là do trình biên dịch thực hiện. Một số trình biên dịch thông minh sẽ cho ra cảnh báo nếu ta vô tình lấy giá trị của một biến không được khởi động trước.
    
     